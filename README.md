# Malware-URL
Web service which informs if a website has malware or not

## Getting Started

This document explains how to successfully call the Malware url lookup API

### Before You Start

You will need the following prerequites 

* Python 3+ version
* Flask 
* Sqlite3

#### 1. Installing Python

Use this link to download and install python 3+ on your system
https://www.python.org/downloads/

Make sure to check add python to path checkbox for windows installation

#### 2. Installing Dependencies

For flask 

pip intsall flask

for sqlite3

pip install sqlite

Note: if this doesnt work for your system try using a virtual environment and make use of pip3 while intsalling

### Running the Service

Clone the project using the link https://github.com/therealameya/Malware-URL.git

Or

Simply download the zip and export it to a folder

Open the terminal(command line / powershell) in the folder you extracted the project and run this command.

For Linux and Mac:
export FLASK_APP=app.py

For Windows:
set FLASK_APP=app.py

Now type "flask run" in terminal this would run the flask project i.e. the web service.


## API Documentation

### Get URL Info

```
GET /v1/urlinfo/{resource_url_with_query_string}
```
Along with the url_string we also need to pass api_key parameter for authenctication.
(For this demo api_key is hardcoded as "abc123")

| Parameter | Type | Description |
| :--- | :--- | :--- |
| `api_key` | `string` | **Required**. Your Access API key |


### Respone Structure
```
{
    "safe": true,
    "details": {
        "type": "",
        "date_added": ""
    }
}
```
If the URL is known to contain malware, the safe field would be 'false' and the details field would contain information about the type of  malware. If the URL is not known to contain any malware, the safe field would be true and the details field would be empty.

**Example 1**

#### Request

Here,

url = abc.com
api_key = abc123

```
http://127.0.0.1:5000/v1/urlinfo/abc.com?api_key=abc123
```

Here,

url = abc.com
api_key = abc123

#### Response

```
{
	"safe":false,
	"details": {
		"date_added":"2022-01-01",
		"type":"Trojan",
		"url":"abc.com"
	}
}
```

As the URL is known to contain malware, the safe field returns false and the details field contain information about the malware type. 


**Example 2 **

#### Request

Here,

url = abc.com
api_key = abc123

```
http://127.0.0.1:5000/v1/urlinfo/abc1.com?api_key=abc123
```

Here,

url = abc1.com
api_key = abc123

#### Response

```
{"safe":true}
```

As the URL is known to contain malware, the safe field returns true and returns no details section.


### Add URL endpoint

This API endpoint can be used report a about a malware url to our service

```
GET /v1/addurl{paramters}
```

| Parameter | Type | Description |
| :--- | :--- | :--- |
| `api_key` | `string` | **Required**. Your Access API key |
| `url` | `string` | **Required**. URL with Malware |
| `type` | `string` | **Required**. Type of Malware |

**Example 1**


#### Request
```
http://localhost:5000/v1/addurl?api_key=abc123&url=example2.com&type=Trojan
```

#### Response
```
{"success":true}
```

### Authentication



GET v1/get_token/{API_KEY}


{
	API_TOKEN : "abc123",
	expiry: 

}


### BONUS


Q1. The size of the URL list could grow infinitely, how might you scale this beyond the memory capacity of the system? 

We can make use of some techniques for scaling out storage systems to support large number of URLs

* Use caching for storing heavily requested URLs, we can use Redis or Memcached, to store the most recently accessed URLs in memory, so that you don't have to look them up in the database each time. This would reduce the load on the database and improve the performance of the service.

* Distributed storage: Instead of storing all of the URLs in a single database, we could use a distributed storage system, such as Apache Cassandra or MongoDB, to store the URLs across multiple servers. This would allow you to scale the service horizontally and handle a larger volume of URLs. eg.  For store .us domains in USA DB server whereas store .eu domains in Europe DB servers etc.

* DB Sharding - We need use MongoDB, as it supports sharding. We can shard URL list across multiple servers to distribute the load and improve the performance of the service.

* Indexing - We have already implemented indexing on the url column, its speeds up the query and improves the performance of the system.

* Internal and External Load Balancers : We can use load balancing to distribute the requests across multiple instances of the service. This would allow the service to scale horizontally and handle a higher volume of requests.

Here is the System design for scalable system.

![System Design](sys_design.png)


Q2. The number of requests may exceed the capacity of this system, how might you solve that?

We can use the system design mentioned above to solve the problem.

* Use load balancing to use more servers for increased loads. We can use load balancers between caller and service, and between service and cache or cache and DB wherever we need to scale in case of a large number of requests.

* Asynchronous processing : We could use an asynchronous task queue, such as RabbitMQ or Celery, to process the requests in the background. This would allow the service to respond to requests more quickly and scale better under high load.

* If one caller is sending more requests than expected then use the rate limiting to control the number of requests from the caller. For example, if a service can allow 10 requests in 5mins and the caller sends more than 10 requests in the 5mins gap then we send back an error 429 too many requests and not process it further.


